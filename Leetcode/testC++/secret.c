#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
/**********************************************************************************************
1. 进程创建、、、、 刷新缓存区问题
 * 就没有问题了（就是6个“-”了），因为程序遇到“\n”，或是EOF，或是缓中区满，或是文件描述符关闭，或是主动flush，或是程序退出，
 * 就会把数据刷出缓冲区。需要注意的是，标准输出是行缓冲，所以遇到“\n”的时候会刷出缓冲区，但对于磁盘这个块设备来说，
 * “\n”并不会引起缓冲区刷出的动作，那是全缓冲，你可以使用setvbuf来设置缓冲区大小，或是用fflush刷缓存。
 *********************************************************************************************/
void testfork()
{
    fork(); printf("#\n");  //fork一个进程
    fork(); printf("#\n");  //fork一个进程
    fork(); printf("#\n");  //fork一个进程  
    sleep(100);
}
/**********************************************************************************************
2. 下面的程序并不见得会输出 hello-std-out，块设备 字符设备 区别 
参考答案：stdout和stderr是不是同设备描述符。stdout是块设备，stderr则不是。对于块设备，
只有当下面几种情况下才会被输入，1）遇到回车，2）缓冲区满，3）flush被调用。而stderr则不会。
 *********************************************************************************************/
int test02()  
{
    while(1)
    {
        fprintf(stdout,"hello-std-out");//stdout 块设备需要主动刷新缓冲区
        fprintf(stderr,"hello-std-err");
        //fflush(stdout);
        sleep(1);
    }
    return 0;
}
/**********************************************************************************************
3. 下面的程序看起来是正常的，使用了一个逗号表达式来做初始化。可惜这段程序是有问题的。你知道为什么呢？
参考答案：这个程序会得到编译出错（语法出错），逗号表达式是没错，可是在初始化和变量声明时，逗号并不是逗号表达式的意义。
这点要区分，要修改上面这个程序，你需要加上括号： int a = (1,2);
 *********************************************************************************************/
#define PrintInt(expr) printf("%s : %dn",#expr,(expr))
int test03()
{
    int a = (1,2);
    printf("a : %d\n",a);
    return 0;
}
/**********************************************************************************************
4. 下面的程序会有什么样的输出呢？
参考答案：程序会输出4321，你知道为什么吗？要知道为什么，你需要知道printf的返回值是什么。printf返回值是输出的字符个数。
 *********************************************************************************************/
int test04()
{
    int i = 43;
    printf("%d\n",printf("%d",printf("%d",i)));
    return 0;
}
/**********************************************************************************************
 5. 为什么要引入cout?
原因是：浮点数是4个字节，12.5f 转成二进制是：01000001010010000000000000000000，十六进制是：0x41480000，十进制是:1095237632。
所以，第二和第三个输出相信大家也知道是为什么了。
而对于第一个，为什么会输出0，我们需要了解一下float和double的内存布局，如下：
float:  1位符号位(s)、8位指数(e)， 23位尾数(m,共32位)
double: 1位符号位(s)、11位指数(e)，52位尾数(m,共64位)
然后，我们还需要了解一下printf由于类型不匹配，所以，会把float直接转成double，
注意，12.5的float和double的内存二进制完全不一样。别忘了在x86芯片下使用是的反字节序，高位字节和低位字位要反过来。所以：
float版：0x41480000          (在内存中是：00 00 48 41)
double版：0x4029000000000000 (在内存中是：00 00 00 00 00 00 29 40)
而我们的%d要求是一个4字节的int，对于double的内存布局，我们可以看到前四个字节是00，所以输出自然是0了。
这个示例向我们说明printf并不是类型安全的，这就是为什么C++要引如cout的原因了。
 *********************************************************************************************/
int test05()  
{
    double a = 12.5;
    char bb[sizeof(double)] = {};
    memcpy(bb,&a,sizeof(a));
    int i = 0;
    printf("sizeof(int) = %d \n", sizeof(int));
    for(;i < sizeof(double);i++)
    {
        printf("%02x ", bb[i]);
    }
    printf("\n");
    printf("a:%d\n", a);
    printf("(int)a:%d\n", (int)a);
    printf("*(int *)&a:%d\n", *(int *)&a);  // 强制转换并取前4字节
    return 0;  
}
/**********************************************************************************************
6. 下面，我们再来看一个交叉编译的事情，下面的两个文件可以编译通过吗？如果可以通过，结果是什么？
 *********************************************************************************************/
#if 0
file1.c
  int arr[80];
file2.c
extern int *arr;
int main()  
{      
    arr[1] = 100;
    printf("%d\n", arr[1]);
    return 0;  
}
参考答案：该程序可以编译通过，但运行时会出错。为什么呢？原因是，在另一个文件中用 extern int *arr来外部声明一个数组并
不能得到实际的期望值，因为他们的类型并不匹配。所以导致指针实际并没有指向那个数组。注意：一个指向数组的指针，并不等于一
个数组。修改：extern int arr[]。（参考：ISO C语言 6.5.4.2 节）
#endif
/**********************************************************************************************
7. 请说出下面的程序输出是多少？并解释为什么？（注意，该程序并不会输出 “b is 20″）
参考答案：该程序在编译时，可能会出现一条warning: unreachable code at beginning of switch statement。我们以为进入switch后
，变量b会被初始化，其实并不然，因为switch-case语句会把变量b的初始化直接就跳过了。所以，程序会输出一个随机的内存值。
 *********************************************************************************************/
int test07()  
{      
    int a = 1;      
    switch(a)      
    {   
        int b=20;          
        case 1: 
            printf("b is %d\n",b);
            break;
        default:
            printf("b is %d\n",b);
            break;
    }
    return 0;
}

/**********************************************************************************************
8. 请问下面的程序会有什么潜在的危险？
这个程序的潜在问题是，如果用户输入了超过80个长度的字符，那么就会有数组越界的问题了，你的程序很有可以及会crash了。
 *********************************************************************************************/

int test08()  
{      
    char str[80];
    printf("Enter the string:");
    scanf("%s",str);
    printf("You entered:%s\n",str);
    return 0;
}
/**********************************************************************************************
9. 参考答案：如果你觉得输出分别是，10，4，11，那么你就错了，错在了第三个，第一个是10没有什么问题，第二个是4，也没有什么问题，
因为是32位机上一个int有4个字节。但是第三个为什么输出的不是11呢？居然还是10？原因是，sizeof不是一个函数，是一个操作符，
其求i++的类型的size，这是一件可以在程序运行前（编译时）完全的事情，所以，sizeof(i++)直接就被4给取代了，在运行时也就不会有了i++这个表达式。
 *********************************************************************************************/
int test09()  
{
    int i;
    i = 10;
    printf("i : %d\n",i);
    printf("sizeof(i++) is: %d\n",sizeof(i++));
    printf("i : %d\n",i);
    return 0;
}

/**********************************************************************************************
10. 请问下面的程序的输出值是什么？
参考答案：好吧，如果你对于PrintInt这个宏有问题的话，你可以去看一看《语言的歧义》中的第四个示例。不过，本例的问题不在这里，
本例的输出会是：1，8，64，1000，其实很简单了，以C/C++中，以0开头的数字都是八进制的。
 *********************************************************************************************/
#define SIZEOF(arr) (sizeof(arr)/sizeof(arr[0]))
#define PrintInt(expr) printf("%s:%d\n",#expr,(expr))
int test10()
{
    /* The powers of 10 */
    int pot[] = {
                    0001,
                    0010,
                    0100,
                    1000
                };
    int i;
    for(i=0;i<SIZEOF(pot);i++)
        PrintInt(pot[i]);    
    return 0;
}

/**********************************************************************************************
11.请问下面的程序输出是什么？（绝对不是10）
参考答案：本题输出的是100。为什么呢？问题就出在 y = y/*p;上了，我们本来想的是 y / (*p) ，然而，
我们没有加入空格和括号，结果y/*p中的 /*被解释成了注释的开始。于是，这也是整个恶梦的开始。
 *********************************************************************************************/
int test11()  
{
    int y = 100;
    int *p;
    p = malloc(sizeof(int));
    *p = 10;
    y = y/(*p); /*dividing y by *p */
    PrintInt(y);
    return 0;
}

/**********************************************************************************************
12. 参考答案：本题并不简单的是考前缀++或反缀++，本题主要考的是&&和||的短路求值的问题。所为短路求值：对于（条件1 && 条件2），
如果“条件1”是false，那“条件2”的表达式会被忽略了。对于（条件1 || 条件2），如果“条件1”为true，而“条件2”的表达式则被忽略了。
所以，我相信你会知道本题的答案是什么了。
 *********************************************************************************************/
int test12()  
{
    int i = 6;
    if( ((++i < 7) && ( i++/6)) || (++i <= 9))
        ;
    printf("%d\n",i);
    return 0;
}

/**********************************************************************************************
13. 
如果你知道：a[i] 其实就是 *(a+i)也就是 *(i+a)，所以如果写成 i[a] 应该也不难理解了。
 *********************************************************************************************/
int test13()  
{ 
    int a = 3, b = 5;
    printf(&a["Ya!Hello! how is this? %s\n"], &b["junk/super"]);
    printf(&a["WHAT%c%c%c  %c%c  %c !\n"], 1["this"], 2["beauty"],0["tool"],0["is"],3["sensitive"],4["CCCCCC"]);
    return 0;  
}
/**********************************************************************************************
14. 请问下面的程序输出什么？（假设：输入 Hello, World）
参考答案：本例的输出是“Hello, Wo”，scanf中的”%[^r]”是从中作梗的东西。意思是遇到字符r就结束了。
 *********************************************************************************************/
int test14()  
{ 
    char dummy[80];
    printf("Enter a string:\n");
    scanf("%[^r]",dummy);
    printf("%s\n",dummy);
    return 0;
}
int main()
{ 
    //1. 进程创建、、、、 刷新缓存区问题
    //testfork();
    //2. 下面的程序并不见得会输出 hello-std-out，你知道为什么吗？
    //test02();
    //test03();
    //test04();
    // test05();
    // test12();
     test13();
     test14();
}

